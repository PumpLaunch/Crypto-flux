<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CryptoFlux Pro - Pump.fun Sniper</title>
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <style>
        :root {
            --bg-primary: #0a0e27;
            --bg-secondary: #131937;
            --accent-green: #00ff88;
            --accent-red: #ff3366;
            --accent-purple: #9945ff;
            --text-primary: #ffffff;
            --border-color: #2a3457;
        }
        body {
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: 'Segoe UI', system-ui, sans-serif;
            margin: 0;
            padding: 16px;
            line-height: 1.5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }
        .logo {
            font-size: 1.6rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-primary {
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-green));
            color: white;
        }
        .btn-secondary {
            background: var(--bg-secondary);
            color: white;
            border: 1px solid var(--border-color);
        }
        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 1.2rem;
            margin-bottom: 1.2rem;
        }
        .signal-item {
            background: rgba(153, 69, 255, 0.1);
            border-left: 3px solid var(--accent-purple);
            padding: 12px;
            margin: 8px 0;
            border-radius: 8px;
        }
        .status {
            font-family: monospace;
            font-size: 0.9rem;
            color: #8892b0;
            margin-top: 10px;
        }
        .positive { color: var(--accent-green); }
        .negative { color: var(--accent-red); }
        input, select {
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: white;
            padding: 4px 8px;
            margin: 4px 0;
            width: 100%;
            box-sizing: border-box;
        }
        label {
            display: block;
            margin: 8px 0 4px;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">CryptoFlux Pro</div>
            <button id="connectBtn" class="btn btn-primary">Connecter Wallet</button>
        </div>

        <div id="app" style="display:none;">
            <div class="card">
                <div><strong>Wallet :</strong> <span id="address">...</span></div>
                <div><strong>Solde :</strong> <span id="balance">0.00</span> SOL</div>
                <div><strong>R√©seau :</strong> Mainnet</div>
            </div>

            <div class="card">
                <h3>‚öôÔ∏è Param√®tres Auto-Trade</h3>
                <label>Achat (SOL):</label>
                <input type="number" id="buyAmount" value="0.05" step="0.01" min="0.01">
                
                <label>√Çge max (sec):</label>
                <input type="number" id="maxAge" value="300" min="10">
                
                <label>Marketcap min ($):</label>
                <input type="number" id="minMarketcap" value="10000" min="0">
                
                <label>D√©tenteurs min:</label>
                <input type="number" id="minHolders" value="50" min="1">
                
                <label>Frais prioritaires:</label>
                <select id="priorityFee">
                    <option value="100000">√âlev√©</option>
                    <option value="1000000">Turbo</option>
                    <option value="5000000">Extr√™me</option>
                </select>
                
                <button id="toggleScan" class="btn btn-primary" style="margin-top: 16px;">‚ñ∂Ô∏è D√©marrer le Scan</button>
                <div class="status" id="scanStatus">Inactif</div>
            </div>

            <div class="card">
                <h3>üîî Signaux D√©tect√©s</h3>
                <div id="signals">Aucun signal</div>
            </div>
        </div>

        <div id="status">Ouvrez cette page dans l'app Phantom ‚Üí Browser.</div>
    </div>

    <script>
        // ===== CONFIGURATION =====
        const HELIUS_API_KEY = '1e8ea51d-3bed-4100-ad49-a6a7635c171a';
        const HELIUS_RPC_URL = `https://mainnet.helius-rpc.com/?api-key=${HELIUS_API_KEY}`;
        
        const PUMP_PROGRAM_ID = '6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P';
        const PUMP_FEE_RECIPIENT = 'CebN5WGQ4jvEPvsVU4EoHEpgzq1VV7AbicfhtW4xC9iM';
        const RENT_SYSVAR = 'SysvarRent111111111111111111111111111111111';
        const BUY_DISCRIMINATOR = [0x66, 0x06, 0x3d, 0x12, 0x01, 0xda, 0xeb, 0xea];

        // ===== √âl√©ments DOM =====
        const statusEl = document.getElementById('status');
        const appEl = document.getElementById('app');
        const connectBtn = document.getElementById('connectBtn');
        const addressEl = document.getElementById('address');
        const balanceEl = document.getElementById('balance');
        const toggleScanBtn = document.getElementById('toggleScan');
        const signalsEl = document.getElementById('signals');
        const scanStatusEl = document.getElementById('scanStatus');

        // ===== √âtat global =====
        let provider = null;
        let connection = null;
        let isScanning = false;
        let scanInterval = null;
        let lastProcessedMint = null;

        // ===== URL de la fonction Netlify =====
        const NETLIFY_FUNCTION_URL = 'https://gentle-kelpie-dfcb5a.netlify.app/.netlify/functions/pump-signal';

        // ===== Utilitaires =====
        function getInjectedProvider() {
            if (window.phantom?.solana?.isPhantom) return window.phantom.solana;
            if (window.solflare) return window.solflare;
            if (window.solana) return window.solana;
            return null;
        }

        function log(msg) {
            console.log('[CryptoFlux]', msg);
            statusEl.textContent = msg;
        }

        function encodeU64(value) {
            const buffer = new ArrayBuffer(8);
            const view = new DataView(buffer);
            view.setBigUint64(0, BigInt(value), true);
            return new Uint8Array(buffer);
        }

        // ===== Connexion wallet =====
        async function connectWallet() {
            provider = getInjectedProvider();
            if (!provider) {
                log("‚ùå Ouvrez cette page dans Phantom Browser.");
                return;
            }

            try {
                log("Connexion au wallet...");
                const resp = await provider.connect();
                const pubKey = resp.publicKey.toString();

                connection = new solanaWeb3.Connection(HELIUS_RPC_URL, 'confirmed');
                const balanceLamports = await connection.getBalance(resp.publicKey);
                const balanceSol = balanceLamports / solanaWeb3.LAMPORTS_PER_SOL;

                addressEl.textContent = `${pubKey.slice(0,6)}...${pubKey.slice(-4)}`;
                balanceEl.textContent = balanceSol.toFixed(4);

                appEl.style.display = 'block';
                log("‚úÖ Connect√© !");

                if (provider.on) {
                    provider.on('disconnect', () => {
                        appEl.style.display = 'none';
                        log("D√©connect√©");
                    });
                }
            } catch (err) {
                console.error(err);
                log(`‚ùå ${err.message || 'Annul√©'}`);
            }
        }

        // ===== Enrichissement token =====
        async function enrichTokenInfo(mintAddress) {
            try {
                const heliusUrl = HELIUS_RPC_URL;
                const metadataRes = await fetch(heliusUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 'token-info',
                        method: 'getTokenMetadata',
                        params: { mint: mintAddress }
                    })
                });
                const metadataData = await metadataRes.json();
                const metadata = metadataData.result;

                if (!metadata || !metadata.pumpFun) return null;

                const totalSupply = metadata.tokenInfo?.supply ? 
                    parseInt(metadata.tokenInfo.supply) / Math.pow(10, metadata.tokenInfo.decimals || 9) : 0;
                const virtualSolReserves = metadata.pumpFun.virtualSolReserves || 0;
                const pricePerToken = totalSupply > 0 ? virtualSolReserves / totalSupply : 0;
                const marketcapUsd = pricePerToken * virtualSolReserves * 150;

                const holdersRes = await fetch(heliusUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 'holders',
                        method: 'getTokenHolders',
                        params: { mint: mintAddress, limit: 1000 }
                    })
                });
                const holdersData = await holdersRes.json();
                const holderCount = holdersData.result?.length || 0;

                const accountInfo = await connection.getAccountInfo(new solanaWeb3.PublicKey(mintAddress));
                const blockTime = accountInfo?.slot ? await connection.getBlockTime(accountInfo.slot) : null;
                const ageSeconds = blockTime ? Math.floor(Date.now() / 1000 - blockTime) : Infinity;

                return {
                    mint: mintAddress,
                    name: metadata.tokenInfo?.name || 'Unknown',
                    symbol: metadata.tokenInfo?.symbol || '???',
                    marketcapUsd: marketcapUsd,
                    holderCount: holderCount,
                    ageSeconds: ageSeconds,
                    priceSol: pricePerToken
                };
            } catch (err) {
                console.error("Enrichissement √©chou√©:", err);
                return null;
            }
        }

        // ===== Filtres =====
        function passesFilters(tokenInfo) {
            const maxAge = parseInt(document.getElementById('maxAge').value) || 300;
            const minMarketcap = parseFloat(document.getElementById('minMarketcap').value) || 10000;
            const minHolders = parseInt(document.getElementById('minHolders').value) || 50;

            return (
                tokenInfo.ageSeconds <= maxAge &&
                tokenInfo.marketcapUsd >= minMarketcap &&
                tokenInfo.holderCount >= minHolders
            );
        }

        // ===== Achat r√©el Pump.fun =====
        async function buyToken(mintAddress) {
            if (!provider || !connection || !provider.publicKey) {
                log("‚ùå Wallet non connect√©");
                return;
            }

            const buyAmountSol = parseFloat(document.getElementById('buyAmount').value) || 0.05;
            const priorityFeeLamports = parseInt(document.getElementById('priorityFee').value) || 100000;
            const buyAmountLamports = buyAmountSol * solanaWeb3.LAMPORTS_PER_SOL;

            try {
                log(`Pr√©paration achat pour ${mintAddress}...`);

                const [pumpGlobal] = solanaWeb3.PublicKey.findProgramAddressSync(
                    [Buffer.from("global")],
                    new solanaWeb3.PublicKey(PUMP_PROGRAM_ID)
                );
                const [pumpTokenAccount] = solanaWeb3.PublicKey.findProgramAddressSync(
                    [Buffer.from("token_account"), new solanaWeb3.PublicKey(mintAddress).toBuffer()],
                    new solanaWeb3.PublicKey(PUMP_PROGRAM_ID)
                );
                const [userTokenAccount] = solanaWeb3.PublicKey.findProgramAddressSync(
                    [
                        provider.publicKey.toBuffer(),
                        new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA").toBuffer(),
                        new solanaWeb3.PublicKey(mintAddress).toBuffer()
                    ],
                    new solanaWeb3.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL")
                );

                const transaction = new solanaWeb3.Transaction();
                transaction.feePayer = provider.publicKey;
                const { blockhash } = await connection.getLatestBlockhash();
                transaction.recentBlockhash = blockhash;

                transaction.add(
                    solanaWeb3.ComputeBudgetProgram.setComputeUnitLimit({ units: 200000 }),
                    solanaWeb3.ComputeBudgetProgram.setComputeUnitPrice({ microLamports: priorityFeeLamports })
                );

                const userTokenAccountInfo = await connection.getAccountInfo(userTokenAccount);
                if (!userTokenAccountInfo) {
                    transaction.add(
                        solanaWeb3.SystemProgram.createAccount({
                            fromPubkey: provider.publicKey,
                            newAccountPubkey: userTokenAccount,
                            lamports: await connection.getMinimumBalanceForRentExemption(165),
                            space: 165,
                            programId: new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA")
                        }),
                        new solanaWeb3.TransactionInstruction({
                            keys: [
                                { pubkey: userTokenAccount, isSigner: false, isWritable: true },
                                { pubkey: new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"), isSigner: false, isWritable: false },
                                { pubkey: provider.publicKey, isSigner: true, isWritable: false }
                            ],
                            programId: new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
                             Buffer.from([9])
                        })
                    );
                }

                const buyInstruction = new solanaWeb3.TransactionInstruction({
                    keys: [
                        { pubkey: provider.publicKey, isSigner: true, isWritable: true },
                        { pubkey: pumpGlobal, isSigner: false, isWritable: false },
                        { pubkey: new solanaWeb3.PublicKey(PUMP_FEE_RECIPIENT), isSigner: false, isWritable: true },
                        { pubkey: pumpTokenAccount, isSigner: false, isWritable: true },
                        { pubkey: userTokenAccount, isSigner: false, isWritable: true },
                        { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false },
                        { pubkey: new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"), isSigner: false, isWritable: false },
                        { pubkey: new solanaWeb3.PublicKey(RENT_SYSVAR), isSigner: false, isWritable: false }
                    ],
                    programId: new solanaWeb3.PublicKey(PUMP_PROGRAM_ID),
                     Buffer.concat([
                        Buffer.from(BUY_DISCRIMINATOR),
                        Buffer.from(encodeU64(buyAmountLamports))
                    ])
                });

                transaction.add(buyInstruction);
                log("Demande de signature dans Phantom...");
                const signed = await provider.signTransaction(transaction);
                const txid = await connection.sendRawTransaction(signed.serialize());
                log(`‚úÖ Achat envoy√© ! https://solscan.io/tx/${txid}`);
                await connection.confirmTransaction(txid, 'confirmed');
                log(`üîó Confirm√©`);

            } catch (err) {
                console.error(err);
                log(`‚ùå √âchec: ${err.message || err}`);
            }
        }

        // ===== Scanner en temps r√©el =====
        async function pollForSignals() {
            try {
                const response = await fetch(NETLIFY_FUNCTION_URL);
                const signal = await response.json();
                
                if (signal.mint && signal.mint !== lastProcessedMint) {
                    lastProcessedMint = signal.mint;
                    const enriched = await enrichTokenInfo(signal.mint);
                    if (enriched && passesFilters(enriched)) {
                        const signalEl = document.createElement('div');
                        signalEl.className = 'signal-item';
                        signalEl.innerHTML = `
                            <strong>${enriched.name} (${enriched.symbol})</strong><br>
                            √Çge: ${enriched.ageSeconds}s | MC: ${Math.round(enriched.marketcapUsd)}$ | Holders: ${enriched.holderCount}<br>
                            Prix: ${enriched.priceSol.toFixed(6)} SOL<br>
                            <button class="btn btn-secondary" onclick="buyToken('${enriched.mint}')">
                                Acheter maintenant
                            </button>
                        `;
                        signalsEl.prepend(signalEl);
                        while (signalsEl.children.length > 5) {
                            signalsEl.removeChild(signalsEl.lastChild);
                        }
                        log(`üîî Signal r√©el: ${enriched.symbol}`);
                    }
                }
            } catch (err) {
                console.error("Polling √©chou√©:", err);
            }
        }

        function toggleScan() {
            if (isScanning) {
                clearInterval(scanInterval);
                isScanning = false;
                toggleScanBtn.textContent = "‚ñ∂Ô∏è D√©marrer le Scan";
                scanStatusEl.textContent = "Arr√™t√©";
                scanStatusEl.className = "status";
            } else {
                isScanning = true;
                toggleScanBtn.textContent = "‚èπÔ∏è Arr√™ter le Scan";
                scanStatusEl.textContent = "√âcoute Pump.fun...";
                scanStatusEl.className = "status positive";
                scanInterval = setInterval(pollForSignals, 3000);
                log("üîç Scan en temps r√©el activ√©");
            }
        }

        // Exposer globalement
        window.buyToken = buyToken;

        // ===== Initialisation =====
        connectBtn.addEventListener('click', connectWallet);
        toggleScanBtn.addEventListener('click', toggleScan);

        if (getInjectedProvider()) {
            log("Wallet d√©tect√©. Cliquez pour connecter.");
        }
    </script>
</body>
</html>
